#!/usr/bin/env python3
"""
Script to generate C# enum files from merged_output.json
"""

import json
import os
from typing import Dict, Any, List

# Type mapping from JSON types to C# types
TYPE_MAPPING = {
    "uint32": "uint",
    "uint16": "ushort",
    "uint8": "byte",
    "uint64": "ulong",
    "int32": "int",
    "int16": "short",
    "int8": "sbyte",
    "int64": "long",
    "int": "int",
    "uint": "uint",
    "byte": "byte",
    "short": "short",
    "ushort": "ushort",
    "long": "long",
    "ulong": "ulong",
}

# Template for enum generation
ENUM_TEMPLATE = """// <auto-generated />

using ServerGui.Schemas;

namespace ServerGui.Schemas.Enums;

public enum {ENUM_NAME} : {BASE_TYPE} {{
{ENUM_VALUES}
}}
"""

INPUT_FILE = "merged_output.json"
OUTPUT_DIR = "GeneratedEnums"


def map_type_to_csharp(json_type: str) -> str:
    """Map JSON type to C# type."""
    json_type_lower = json_type.lower()
    return TYPE_MAPPING.get(json_type_lower, "int")  # Default to int if unknown


def format_enum_value(member_name: str, value: int, base_type: str) -> str:
    """Format a single enum value with proper indentation."""
    # Ensure member name starts with a letter or underscore for C# naming rules
    if member_name and not member_name[0].isalpha() and member_name[0] != '_':
        member_name = '_' + member_name
    
    # Handle negative values for uint types
    if base_type == "uint" and value < 0:
        value_str = "uint.MaxValue"
    elif base_type == "byte" and value < 0:
        value_str = "byte.MaxValue"
    elif base_type == "ulong" and value < 0:
        value_str = "ulong.MaxValue"
    elif base_type == "ushort" and value < 0:
        value_str = "ushort.MaxValue"
    else:
        value_str = str(value)
    
    return f"    {member_name} = {value_str},"


def generate_enum_code(enum_name: str, enum_data: Dict[str, Any]) -> str:
    """Generate C# enum code from enum definition."""
    # Get base type
    base_type = map_type_to_csharp(enum_data.get("type", "uint32"))
    
    # Get members and sort them by value
    members = enum_data.get("members", {})
    sorted_members = sorted(members.items(), key=lambda x: x[1])
    
    # Format enum values
    enum_values = []
    for member_name, value in sorted_members:
        enum_values.append(format_enum_value(member_name, value, base_type))
    
    enum_values_str = "\n".join(enum_values)
    
    # Fill template
    return ENUM_TEMPLATE.format(
        ENUM_NAME=enum_name,
        BASE_TYPE=base_type,
        ENUM_VALUES=enum_values_str
    )


def collect_all_enums(data: Dict[str, Any]) -> Dict[str, Dict[str, Any]]:
    """Collect all enums from the merged JSON structure."""
    all_enums = {}
    
    # Iterate through top-level keys (DLL names)
    for dll_name, dll_data in data.items():
        if isinstance(dll_data, dict) and "enums" in dll_data:
            enums_dict = dll_data["enums"]
            if isinstance(enums_dict, dict):
                for enum_name, enum_data in enums_dict.items():
                    # Handle duplicate enum names by prefixing with DLL name if needed
                    if enum_name in all_enums:
                        # Check if it's the same enum or different
                        existing_enum = all_enums[enum_name]
                        if existing_enum != enum_data:
                            # Different enum with same name - use qualified name
                            qualified_name = f"{dll_name}_{enum_name}"
                            print(f"  Warning: Duplicate enum name '{enum_name}', using '{qualified_name}' for second occurrence")
                            all_enums[qualified_name] = enum_data
                        # If same, skip duplicate
                    else:
                        all_enums[enum_name] = enum_data
    
    return all_enums


def main():
    """Main function to generate enum files."""
    print("=" * 60)
    print("C# Enum Generator")
    print("=" * 60)
    print()
    
    # Check if input file exists
    if not os.path.exists(INPUT_FILE):
        print(f"✗ Error: {INPUT_FILE} not found!")
        print(f"  Please run merge_json_files.py first to generate {INPUT_FILE}")
        return
    
    # Load merged JSON
    print(f"Loading {INPUT_FILE}...")
    try:
        with open(INPUT_FILE, 'r', encoding='utf-8') as f:
            data = json.load(f)
        print(f"✓ Successfully loaded {INPUT_FILE}")
    except Exception as e:
        print(f"✗ Failed to load {INPUT_FILE}: {e}")
        return
    
    # Collect all enums
    print("\nCollecting all enums...")
    all_enums = collect_all_enums(data)
    print(f"✓ Found {len(all_enums)} enum(s)")
    
    if not all_enums:
        print("No enums found in the JSON file!")
        return
    
    # Create output directory
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    print(f"\nOutput directory: {OUTPUT_DIR}/")
    
    # Generate enum files
    print("\nGenerating C# enum files...")
    generated_count = 0
    
    for enum_name, enum_data in sorted(all_enums.items()):
        try:
            enum_code = generate_enum_code(enum_name, enum_data)
            output_file = os.path.join(OUTPUT_DIR, f"{enum_name}.cs")
            
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(enum_code)
            
            generated_count += 1
            print(f"  ✓ Generated {enum_name}.cs")
        except Exception as e:
            print(f"  ✗ Failed to generate {enum_name}: {e}")
    
    print()
    print("=" * 60)
    print(f"✓ Success! Generated {generated_count} enum file(s) in {OUTPUT_DIR}/")
    print("=" * 60)


if __name__ == "__main__":
    main()

